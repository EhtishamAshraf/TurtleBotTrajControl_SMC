# TurtleBot 8-Shape Trajectory Tracking Using FBTC and FBSMC
This repository contains a ROS-based implementation for comparing Flatness-Based Trajectory Control (FBTC) and Flatness-Based Sliding Mode Control (FBSMC) for trajectory tracking on a TurtleBot. The robot is tasked with following an 8-shaped trajectory, and the performance of both control strategies is analyzed using logged data.

### Features
- **ROS Package**: `trajectory_control_pkg`
- **Control Algorithms**:
  - **FBTC**: A control method utilizing differential flatness for trajectory planning and tracking.
  - **FBSMC**: A robust control approach combining sliding mode control with flatness for enhanced disturbance rejection.
- **Trajectory Tracking**:
  - The robot follows an 8-shaped trajectory in both simulation and the physical world.
  - Robot pose data is logged for post-processing and analysis.
- **Data Analysis**:
  - Pose data is saved to an Excel file for further evaluation.
  - Visual comparisons are provided to illustrate the reference trajectory versus the actual trajectory for both FBTC and FBSMC.

## Demo Videos
### FBTC
You can watch the demo video of Trajectory following with FBTC by clicking on the below image

### FBSMC
You can watch the demo video of Trajectory following with FBSMC by clicking on the below image

## Gazebo World
For this project, empty Gazebo world is used as shown below

### Note
Details about cloning the repository are given at the end of this readme file

# 8-shape Trajectory Following
The trajectory is mathematically defined using parametric equations to create a smooth figure-eight path. Two controllers are used for this purpose: 
1.  Flatness-Based Trajectory Controller (FBTC)
2.  Flatness-Based Sliding Mode Controller (FBSMC)
   
The robot starts at a predefined position (X = 0, Y = 0, heading angle = ) and follows the trajectory using real-time velocity commands generated by the controllers. Both methods are compared in terms of tracking accuracy, robustness, and computational efficiency. Data collected during the execution, including actual poses and errors, are logged in an Excel file for analysis. 
Results are visualized as plots, showing the reference trajectory, the robot's actual path with both controllers. The project demonstrates effective trajectory tracking, with comparisons highlighting the strengths of each control method for handling nonlinear dynamics.

### Mathematical Formulation of the Desired Trajectory
The 8-shaped trajectory is generated using parametric equations, defining the desired position, velocity, and acceleration at any given time \( t \). These values are used for accurate trajectory tracking by the controllers.

### Target Trajectory
The desired position of the robot along the $x$- and $y$-axes is defined as:
- $x_{\text{target}} = A \cdot \sin(\omega \cdot t)$
- $y_{\text{target}} = B \cdot \sin(2 \cdot \omega \cdot t)$

**Variables:**
- $A$: Amplitude constant that defines the size of the trajectory along the $x$-axis.
- $B$: Amplitude constant that defines the size of the trajectory along the $y$-axis.
- $\omega$: Angular velocity that controls the speed of traversal.
- $t$: Time variable.

### First Derivative (Velocity)
The velocity components along the $x$- and $y$-axes are given by:
- $\dot{x}_{\text{target}} = A \cdot \omega \cdot \cos(\omega \cdot t)$
- $\dot{y}_{\text{target}} = 2 \cdot B \cdot \omega \cdot \cos(2 \cdot \omega \cdot t)$

These represent the desired linear velocities of the robot.

### Second Derivative (Acceleration)
The acceleration components for the trajectory are derived as:
- $\ddot{x}_{\text{target}} = -A \cdot \omega^2 \cdot \sin(\omega \cdot t)$
- $\ddot{y}_{\text{target}} = -4 \cdot B \cdot \omega^2 \cdot \sin(2 \cdot \omega \cdot t)$

These values are used to refine control inputs and ensure smooth motion tracking.

### Purpose
These equations are implemented in the trajectory tracking code, allowing the controllers (e.g., FBTC and FBSMC) to calculate the necessary control inputs for precise 8-shaped trajectory following by the TurtleBot. The dynamic computation of motion parameters ensures accuracy and robustness during real-time execution.

## Flatness-Based Trajectory Controller (FBTC)

## Flatness-Based Sliding Mode Controller (FBSMC)


# Robot's Pose data
While the robot is following the 8 shape trajectory, its position and orientation data are continuously recorded in a .csv file. This stored data is later utilized to do the comparison of FBTC and FBSMC.
The table below displays some of the logged data obtained from the real Turtlebot3 while the FBSMC controller was in operation. This data includes various parameters such as time, position, orientation, velocity, and angular velocity, which are essential for analyzing the performance of the trajectory-following task.

| Time (s) | x                    | y                     | Theta (radians)       | Theta (degrees) | Linear Velocity (v)                  | Angular Velocity (Omega)            |
|----------|----------------------|-----------------------|-------------|-----------------|--------------------|------------------|
| 0.133758 | 0.0011067477753385901 | -7.501553045585752e-05 | -1.1332132763832972 | -64.92833802495501 | 0.08943836647059063 | 0.03092362431270873 |
| 0.167218 | 0.0011067477753385901 | -7.501553045585752e-05 | -1.1331551730380127 | -64.92500894849462 | 0.08943591655312741 | -0.07375626358991658 |
| 0.200366 | 0.0011067477753385901 | -7.501553045585752e-05 | -1.1331551730380127 | -64.92500894849462 | 0.0894329523006337 | -0.07304968071611222 |
| 0.233720 | 0.0011067477753385901 | -7.501553045585752e-05 | -1.133194195079014 | -64.927244746752  | 0.08942943015010942 | -0.07189733229306967 |
| 0.267050 | 0.0011067477753385901 | -7.501553045585752e-05 | -1.1332190638622996 | -64.92866962307588 | 0.08942536992247803 | -0.07001932135079737 |


# Running the Simulation
Run the following commands on a new terminal:
  ```bash
  source devel/setup.bash
  roslaunch trajectory_control_pkg trajectory_following.launch
  ```
* Remember to run the above commands inside the workspace

# Comparison matlab


# Hardware Testing
Before transitioning to real hardware testing with the TurtleBot, ensure that all necessary setup steps are completed. This section provides an overview of key configurations and usage instructions.

1.  Turn on the Turtlebot3.
2.  Connect your laptop and TurtleBot3 to the same Wi-Fi network.
    * Verify the TurtleBot's IP address via SSH
    * If you would like to use a new wifi which hasn't been configured in turtlebot3 so far then write the WiFi name and password in the command
      
3.  ROS Network Setup:      
  A. Open the `.bashrc` File:
   - Use the `nano` editor to open the `.bashrc` file on both the TurtleBot and your laptop:
     ```bash
     nano ~/.bashrc
     ```

  B. Update the ROS Environment Variables:
   - Add the following lines to the `.bashrc` file **on the TurtleBot**:
     ```bash
     export ROS_MASTER_URI=http://<pc-ip>:11311
     export ROS_HOSTNAME=<turtlebot-ip>
     ```
   - Add the following lines to the `.bashrc` file **on the laptop**:
     ```bash
     export ROS_MASTER_URI=http://<pc-ip>:11311
     export ROS_HOSTNAME=<pc-ip>
     ```

   Replace the placeholders:
   - `<pc-ip>`: The IP address of your laptop.
   - `<turtlebot-ip>`: The IP address of your TurtleBot.

  C. Save and Exit:
   - Press `CTRL+O` to save the changes and `CTRL+X` to exit the editor.

  D. Source the Updated `.bashrc` File:
   - Run the following command to apply the changes:
     ```bash
     source ~/.bashrc
     ```
## Running ROS on TurtleBot3 and Laptop

1. Run `roscore` on the Laptop (ROS Master):
   - On your laptop, start the ROS core:
     ```bash
     roscore
     ```

2. SSH into the TurtleBot:
   - From your laptop, SSH into the TurtleBot:
     ```bash
     ssh ubuntu@<turtlebot-ip>
     ```
   - Replace `<turtlebot-ip>` with the TurtleBot's IP address and enter the password when prompted.

3. Launch TurtleBot Bringup:
   - On the TurtleBot, launch the bringup file to initialize the robot:
     ```bash
     roslaunch turtlebot3_bringup turtlebot3_robot.launch
     ```

4. Test Communication:
   - Verify the TurtleBot is communicating with your laptop:
     ```bash
     rostopic list
     ```

---

#### Checking TurtleBot Movement

Once the above steps are completed, you can test your TurtleBot's hardware functionality:

1. Test Using Teleop:
   - On your laptop, run the teleoperation node to control the TurtleBot manually:
     ```bash
     roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch
     ```

2. Hardware Testing:
   - Run your trajectory nodes or the test scripts provided in the repository for straight-line or circular movement to ensure proper functioning of the TurtleBot.

After following these steps, the TurtleBot should be fully configured and operational in the real-world environment!


# Check Robot Movement
The `trajectory_control_pkg` also includes three essential nodes to verify the robot's proper connection and functionality. These nodes allow you to test straight-line movement, circular movement, and adjust the robot's heading angle. These features help ensure the robot is correctly connected and responding as expected before running more complex control algorithms.

The figure below illustrates the circular trajectory followed by the robot during its movement:

#### Parametric Equations for Circular Trajectory
For the robot to follow a circular trajectory, the desired position along the $x$- and $y$-axes is given by the following parametric equations:

- ${\text{XdesPos}} = \text{radius} \cdot \cos(\text{omega} \cdot t)$  
- ${\text{YdesPos}} = \text{radius} \cdot \sin(\text{omega} \cdot t)$  

The velocity components along the $x$- and $y$-axes are calculated as:

- $Vx = -\text{radius} \cdot \text{omega} \cdot \sin(\text{omega} \cdot t)$  
- $Vy = \text{radius} \cdot \text{omega} \cdot \cos(\text{omega} \cdot t)$  

##### Explanation:
- Radius: Determines the size of the circular path.
- Angular Velocity: Controls how quickly the robot moves along the circular trajectory.
- $time (t)$: Represents the time variable.

